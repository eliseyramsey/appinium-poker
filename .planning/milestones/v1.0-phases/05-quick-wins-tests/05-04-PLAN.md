---
phase: 05-quick-wins-tests
plan: 04
type: tdd
wave: 2
depends_on: [05-03]
files_modified:
  - lib/utils/__tests__/calculations.test.ts
  - lib/utils/__tests__/gameId.test.ts
  - components/memes/__tests__/memeData.test.ts
  - components/ui/__tests__/Button.test.tsx
  - components/ui/__tests__/Input.test.tsx
  - components/game/__tests__/CardSelector.test.tsx
autonomous: true
requirements: [TEST-02, TEST-03]

must_haves:
  truths:
    - "All util functions have 100% test coverage"
    - "Button, Input, CardSelector components have tests"
    - "npm run test passes with all tests green"
  artifacts:
    - path: "lib/utils/__tests__/calculations.test.ts"
      provides: "Tests for calculateAverage, hasConsensus, getVoteSpread, getClosestFibonacci"
      min_lines: 50
    - path: "lib/utils/__tests__/gameId.test.ts"
      provides: "Tests for ID generation functions"
      min_lines: 20
    - path: "components/memes/__tests__/memeData.test.ts"
      provides: "Tests for getMemeCategory"
      min_lines: 40
    - path: "components/ui/__tests__/Button.test.tsx"
      provides: "Button component tests"
      min_lines: 30
    - path: "components/ui/__tests__/Input.test.tsx"
      provides: "Input component tests"
      min_lines: 30
    - path: "components/game/__tests__/CardSelector.test.tsx"
      provides: "CardSelector component tests"
      min_lines: 40
  key_links:
    - from: "lib/utils/__tests__/calculations.test.ts"
      to: "lib/utils/calculations.ts"
      via: "imports"
      pattern: "import.*from.*calculations"
---

<objective>
Write unit tests for utils and component tests for core UI components.

Purpose: Verify business logic correctness, prevent regressions, achieve coverage targets.
Output: Test files with 100% util coverage and 80%+ component coverage.
</objective>

<execution_context>
@/Users/eliseyramsey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliseyramsey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-quick-wins-tests/05-03-SUMMARY.md

@lib/utils/calculations.ts
@lib/utils/gameId.ts
@components/memes/memeData.ts
@components/ui/Button.tsx
@components/ui/Input.tsx
@components/game/CardSelector.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for utility functions</name>
  <files>lib/utils/__tests__/calculations.test.ts, lib/utils/__tests__/gameId.test.ts, components/memes/__tests__/memeData.test.ts</files>
  <action>
Create __tests__ directories and test files.

1. `lib/utils/__tests__/calculations.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { calculateAverage, hasConsensus, getVoteSpread, getClosestFibonacci } from '../calculations';
import type { Vote } from '@/lib/supabase/types';

// Helper to create vote objects
const createVotes = (values: string[]): Vote[] =>
  values.map((value, i) => ({
    id: `vote-${i}`,
    issue_id: 'issue-1',
    player_id: `player-${i}`,
    value,
    created_at: new Date().toISOString(),
  }));

describe('calculateAverage', () => {
  it('returns null for empty votes', () => {
    expect(calculateAverage([])).toBeNull();
  });

  it('calculates average of numeric votes', () => {
    const votes = createVotes(['3', '5', '8']);
    expect(calculateAverage(votes)).toBe(5.3);
  });

  it('ignores ? and coffee votes', () => {
    const votes = createVotes(['3', '5', '?', 'coffee']);
    expect(calculateAverage(votes)).toBe(4);
  });

  it('returns null if all votes are non-numeric', () => {
    const votes = createVotes(['?', 'coffee']);
    expect(calculateAverage(votes)).toBeNull();
  });

  it('rounds to one decimal place', () => {
    const votes = createVotes(['1', '2', '3']);
    expect(calculateAverage(votes)).toBe(2);
  });
});

describe('hasConsensus', () => {
  it('returns false for less than 2 votes', () => {
    expect(hasConsensus(createVotes(['5']))).toBe(false);
    expect(hasConsensus([])).toBe(false);
  });

  it('returns true when all votes are the same', () => {
    expect(hasConsensus(createVotes(['5', '5', '5']))).toBe(true);
  });

  it('returns false when votes differ', () => {
    expect(hasConsensus(createVotes(['5', '8']))).toBe(false);
  });
});

describe('getVoteSpread', () => {
  it('returns 0 for empty or single vote', () => {
    expect(getVoteSpread([])).toBe(0);
    expect(getVoteSpread(createVotes(['5']))).toBe(0);
  });

  it('calculates spread between min and max', () => {
    expect(getVoteSpread(createVotes(['2', '8']))).toBe(6);
    expect(getVoteSpread(createVotes(['1', '3', '5', '13']))).toBe(12);
  });

  it('ignores non-numeric votes', () => {
    expect(getVoteSpread(createVotes(['2', '8', '?']))).toBe(6);
  });
});

describe('getClosestFibonacci', () => {
  it('returns exact match for Fibonacci numbers', () => {
    expect(getClosestFibonacci(5)).toBe(5);
    expect(getClosestFibonacci(13)).toBe(13);
  });

  it('returns closest Fibonacci for non-Fibonacci', () => {
    expect(getClosestFibonacci(4)).toBe(5);
    expect(getClosestFibonacci(6)).toBe(5);
    expect(getClosestFibonacci(7)).toBe(8);
  });
});
```

2. `lib/utils/__tests__/gameId.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { createGameId, createPlayerId, createIssueId, createVoteId } from '../gameId';

describe('ID generation', () => {
  it('createGameId returns 8-character string', () => {
    const id = createGameId();
    expect(id).toHaveLength(8);
    expect(id).toMatch(/^[0-9a-z]+$/);
  });

  it('createPlayerId returns 12-character string', () => {
    const id = createPlayerId();
    expect(id).toHaveLength(12);
    expect(id).toMatch(/^[0-9a-z]+$/);
  });

  it('createIssueId returns 12-character string', () => {
    expect(createIssueId()).toHaveLength(12);
  });

  it('createVoteId returns 12-character string', () => {
    expect(createVoteId()).toHaveLength(12);
  });

  it('generates unique IDs', () => {
    const ids = new Set(Array.from({ length: 100 }, () => createGameId()));
    expect(ids.size).toBe(100);
  });
});
```

3. `components/memes/__tests__/memeData.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { getMemeCategory, selectMeme } from '../memeData';

describe('getMemeCategory', () => {
  it('returns "random" for empty votes', () => {
    expect(getMemeCategory([])).toBe('random');
  });

  it('returns "break" when coffee is voted', () => {
    expect(getMemeCategory(['5', 'coffee'])).toBe('break');
    expect(getMemeCategory(['coffee'])).toBe('break');
  });

  it('returns "confused" when ? is voted', () => {
    expect(getMemeCategory(['5', '?'])).toBe('confused');
  });

  it('prioritizes break over confused', () => {
    expect(getMemeCategory(['coffee', '?'])).toBe('break');
  });

  it('returns "consensus" when all votes are the same', () => {
    expect(getMemeCategory(['5', '5', '5'])).toBe('consensus');
  });

  it('returns "chaos" when spread > 5', () => {
    expect(getMemeCategory(['1', '8'])).toBe('chaos');
    expect(getMemeCategory(['2', '13'])).toBe('chaos');
  });

  it('returns "random" for normal spread', () => {
    expect(getMemeCategory(['3', '5'])).toBe('random');
    expect(getMemeCategory(['5', '8'])).toBe('random');
  });
});

describe('selectMeme', () => {
  it('returns a meme object', () => {
    const meme = selectMeme(['5', '5']);
    expect(meme).toHaveProperty('src');
    expect(meme).toHaveProperty('alt');
  });

  it('returns consistent meme with same seed', () => {
    const meme1 = selectMeme(['5', '8'], 'test-seed');
    const meme2 = selectMeme(['5', '8'], 'test-seed');
    expect(meme1).toEqual(meme2);
  });

  it('returns null for empty category', () => {
    // This shouldn't happen with current MEMES structure, but test the fallback
    expect(selectMeme(['5'])).toBeTruthy(); // All categories have memes
  });
});
```
  </action>
  <verify>
Run `npm run test:run -- --coverage` and verify:
- calculations.ts: 100% coverage
- gameId.ts: 100% coverage
- memeData.ts: getMemeCategory 100% coverage
  </verify>
  <done>
All utility functions have comprehensive unit tests with 100% coverage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Component tests for UI components</name>
  <files>components/ui/__tests__/Button.test.tsx, components/ui/__tests__/Input.test.tsx, components/game/__tests__/CardSelector.test.tsx</files>
  <action>
Create component test files with React Testing Library.

1. `components/ui/__tests__/Button.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from '../Button';

describe('Button', () => {
  it('renders children', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', async () => {
    const user = userEvent.setup();
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click</Button>);

    await user.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('shows loading spinner when isLoading is true', () => {
    render(<Button isLoading>Loading</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
    // Check for spinner SVG
    expect(screen.getByRole('button').querySelector('svg.animate-spin')).toBeInTheDocument();
  });

  it('applies variant styles', () => {
    const { rerender } = render(<Button variant="primary">Primary</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-[var(--primary)]');

    rerender(<Button variant="secondary">Secondary</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-[var(--bg-surface)]');

    rerender(<Button variant="danger">Danger</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-[var(--danger)]');
  });

  it('applies size styles', () => {
    const { rerender } = render(<Button size="sm">Small</Button>);
    expect(screen.getByRole('button')).toHaveClass('px-3', 'py-1.5');

    rerender(<Button size="lg">Large</Button>);
    expect(screen.getByRole('button')).toHaveClass('px-6', 'py-3');
  });
});
```

2. `components/ui/__tests__/Input.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Input } from '../Input';

describe('Input', () => {
  it('renders input element', () => {
    render(<Input />);
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  it('renders label when provided', () => {
    render(<Input label="Email" />);
    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
  });

  it('displays error message', () => {
    render(<Input error="This field is required" />);
    expect(screen.getByText(/this field is required/i)).toBeInTheDocument();
  });

  it('calls onChange when typing', async () => {
    const user = userEvent.setup();
    const handleChange = vi.fn();
    render(<Input onChange={handleChange} />);

    await user.type(screen.getByRole('textbox'), 'hello');
    expect(handleChange).toHaveBeenCalled();
  });

  it('is disabled when disabled prop is true', () => {
    render(<Input disabled />);
    expect(screen.getByRole('textbox')).toBeDisabled();
  });

  it('shows placeholder', () => {
    render(<Input placeholder="Enter your name" />);
    expect(screen.getByPlaceholderText(/enter your name/i)).toBeInTheDocument();
  });

  it('applies error styles when error is present', () => {
    render(<Input error="Error" />);
    expect(screen.getByRole('textbox')).toHaveClass('border-[var(--danger)]');
  });
});
```

3. `components/game/__tests__/CardSelector.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CardSelector } from '../CardSelector';

describe('CardSelector', () => {
  const defaultProps = {
    selectedValue: null,
    onSelect: vi.fn(),
    disabled: false,
  };

  it('renders all voting cards', () => {
    render(<CardSelector {...defaultProps} />);

    // Check for specific card values
    expect(screen.getByRole('button', { name: '0' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '5' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '13' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '?' })).toBeInTheDocument();
  });

  it('calls onSelect when card is clicked', async () => {
    const user = userEvent.setup();
    const handleSelect = vi.fn();
    render(<CardSelector {...defaultProps} onSelect={handleSelect} />);

    await user.click(screen.getByRole('button', { name: '5' }));
    expect(handleSelect).toHaveBeenCalledWith('5');
  });

  it('highlights selected card', () => {
    render(<CardSelector {...defaultProps} selectedValue="8" />);

    const selectedCard = screen.getByRole('button', { name: '8' });
    expect(selectedCard).toHaveClass('bg-[var(--primary)]');
    expect(selectedCard).toHaveClass('-translate-y-2');
  });

  it('disables all cards when disabled', () => {
    render(<CardSelector {...defaultProps} disabled />);

    const cards = screen.getAllByRole('button');
    cards.forEach((card) => {
      expect(card).toBeDisabled();
    });
  });

  it('shows coffee emoji for coffee card', () => {
    render(<CardSelector {...defaultProps} />);
    // Coffee is rendered with emoji in VOTING_CARDS
    const buttons = screen.getAllByRole('button');
    const coffeeButton = buttons.find((btn) => btn.textContent?.includes('coffee') || btn.textContent === 'coffee');
    // Actually, it shows the label which is the emoji
    expect(buttons.some(btn => btn.textContent?.includes('coffee') || btn.textContent === 'coffee')).toBe(true);
  });
});
```
  </action>
  <verify>
Run `npm run test:run` - all tests pass
Run `npm run test:coverage` - components show 80%+ coverage
  </verify>
  <done>
Button, Input, and CardSelector have comprehensive component tests. Coverage targets met.
  </done>
</task>

</tasks>

<verification>
1. `npm run test:run` - all tests pass (0 failures)
2. `npm run test:coverage` - verify coverage:
   - lib/utils/calculations.ts: 100%
   - lib/utils/gameId.ts: 100%
   - components/memes/memeData.ts: 100% (getMemeCategory)
   - components/ui/Button.tsx: 80%+
   - components/ui/Input.tsx: 80%+
   - components/game/CardSelector.tsx: 80%+
3. No TypeScript errors in test files
</verification>

<success_criteria>
- All tests pass
- Utils have 100% coverage
- Components have 80%+ coverage
- Coverage report generates successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-quick-wins-tests/05-04-SUMMARY.md`
</output>
