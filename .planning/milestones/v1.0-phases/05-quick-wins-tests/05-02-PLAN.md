---
phase: 05-quick-wins-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/game/[gameId]/page.tsx
  - components/game/PokerTable.tsx
  - components/ui/ErrorBoundary.tsx
  - app/layout.tsx
autonomous: true
requirements: [QW-02, QW-03, QW-04]

must_haves:
  truths:
    - "User sees loading spinner on buttons during async operations"
    - "User can vote using keyboard number keys (1-0 for cards 0-21)"
    - "User can reveal votes with Enter key (admin only)"
    - "User can deselect card with Escape key"
    - "Component error doesn't crash entire page"
  artifacts:
    - path: "components/ui/ErrorBoundary.tsx"
      provides: "React error boundary with fallback UI"
      min_lines: 30
      exports: ["ErrorBoundary"]
    - path: "app/game/[gameId]/page.tsx"
      provides: "Keyboard event handling"
      contains: "useEffect.*keydown"
  key_links:
    - from: "app/game/[gameId]/page.tsx"
      to: "handleCardSelect"
      via: "keyboard event listener"
      pattern: "addEventListener.*keydown"
    - from: "app/layout.tsx"
      to: "ErrorBoundary"
      via: "component wrapper"
      pattern: "ErrorBoundary"
---

<objective>
Add loading states, keyboard shortcuts, and error boundaries for better UX.

Purpose: Responsive feedback during actions, power-user keyboard support, graceful error handling.
Output: Loading states wired to buttons, keyboard shortcuts in game room, ErrorBoundary component.
</objective>

<execution_context>
@/Users/eliseyramsey/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eliseyramsey/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/game/[gameId]/page.tsx
@components/game/PokerTable.tsx
@components/ui/Button.tsx
@lib/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire loading states to async operations</name>
  <files>app/game/[gameId]/page.tsx, components/game/PokerTable.tsx</files>
  <action>
The Button component already supports `isLoading` prop. Ensure all async operations show loading:

1. In game room page, check existing loading states:
   - `isLoading` is used for Reveal/New Round - already wired
   - `isUpdatingProfile` is used for profile modals - already wired
   - `isContextMenuLoading` is used for context menu - already wired

2. Add missing loading states if any:
   - Card selection (`handleCardSelect`) - add `isVoting` state
   - Confidence vote submission - add loading to ConfidenceVoteModal if not present

3. In PokerTable.tsx, ensure reveal button and new round button show spinner:
   - They receive `isLoading` prop - verify it's passed correctly

4. Check CardSelector - add subtle opacity or disable during vote submission.

Most loading states already exist. Main additions:
- Add `isVoting` state to track card selection in progress
- Pass it to CardSelector as `isSubmitting` prop
- Show subtle loading indicator on selected card during submission
  </action>
  <verify>
1. Click vote card -> card shows brief loading state during API call
2. Click Reveal -> button shows spinner until complete
3. Click New Round -> button shows spinner
4. Profile updates show spinner
  </verify>
  <done>
All async button actions show loading spinners, no silent waiting periods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Keyboard shortcuts for game room</name>
  <files>app/game/[gameId]/page.tsx</files>
  <action>
Add useEffect for keyboard event handling in GameRoomContent:

```typescript
// Keyboard shortcuts
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    // Ignore if typing in input
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
      return;
    }

    // Escape - deselect card
    if (e.key === "Escape" && myVote) {
      handleCardSelect(myVote); // Toggle off
      return;
    }

    // Enter - reveal (admin only, when votes exist)
    if (e.key === "Enter" && isPlayerAdmin && hasVotes && !isRevealed) {
      handleReveal();
      return;
    }

    // Number keys 1-9, 0 for voting
    // Map: 1->0, 2->1, 3->2, 4->3, 5->5, 6->8, 7->13, 8->21, 9->?, 0->coffee
    const keyMap: Record<string, string> = {
      "1": "0",
      "2": "1",
      "3": "2",
      "4": "3",
      "5": "5",
      "6": "8",
      "7": "13",
      "8": "21",
      "9": "?",
      "0": "coffee",
    };

    const cardValue = keyMap[e.key];
    if (cardValue && !isRevealed && currentPlayer && game?.current_issue_id) {
      handleCardSelect(cardValue);
    }
  };

  window.addEventListener("keydown", handleKeyDown);
  return () => window.removeEventListener("keydown", handleKeyDown);
}, [myVote, isPlayerAdmin, hasVotes, isRevealed, currentPlayer, game?.current_issue_id]);
```

Also update CardSelector to show keyboard hints:
- Add small badge on each card showing the shortcut key (1-0)
- Only show when keyboard focus is possible (desktop)
  </action>
  <verify>
1. Press "1" in game room -> selects card "0"
2. Press "5" -> selects card "5"
3. Press "9" -> selects "?"
4. Press "0" -> selects "coffee"
5. Press "Escape" -> deselects current card
6. Press "Enter" as admin with votes -> reveals
7. Typing in input fields doesn't trigger shortcuts
  </verify>
  <done>
Keyboard shortcuts: 1-0 select cards, Escape deselects, Enter reveals (admin). Input fields ignored.
  </done>
</task>

<task type="auto">
  <name>Task 3: Error boundary component</name>
  <files>components/ui/ErrorBoundary.tsx, app/layout.tsx</files>
  <action>
1. Create `components/ui/ErrorBoundary.tsx`:

```typescript
"use client";

import { Component, type ReactNode } from "react";
import { Button } from "./Button";
import { AlertTriangle } from "lucide-react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    // Log to console in development
    console.error("ErrorBoundary caught:", error, info);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: undefined });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex flex-col items-center justify-center min-h-[200px] p-8 text-center">
          <AlertTriangle size={48} className="text-[var(--warning)] mb-4" />
          <h2 className="text-xl font-bold text-[var(--text-primary)] mb-2">
            Something went wrong
          </h2>
          <p className="text-[var(--text-secondary)] mb-4 max-w-md">
            An error occurred while rendering this section.
            Try refreshing or click below to retry.
          </p>
          <Button onClick={this.handleReset} variant="secondary">
            Try Again
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

2. Wrap main content in app/layout.tsx with ErrorBoundary:
   - Import ErrorBoundary
   - Wrap {children} inside the body

3. Optionally wrap specific components (game room, issues sidebar) for granular error handling.
  </action>
  <verify>
1. Temporarily add a component that throws -> shows error fallback UI
2. Click "Try Again" -> component retries
3. Rest of page remains functional
4. Build passes: `npm run build`
  </verify>
  <done>
ErrorBoundary component catches render errors and shows friendly fallback with retry option.
  </done>
</task>

</tasks>

<verification>
1. Async operations show loading states (check buttons)
2. Keyboard shortcuts work in game room
3. Shortcuts don't fire when typing in inputs
4. Error boundary catches component errors
5. Error fallback shows with retry option
6. Build passes without errors
</verification>

<success_criteria>
- All buttons show loading during async operations
- Keyboard shortcuts functional: 1-0 vote, Escape deselect, Enter reveal
- ErrorBoundary prevents full page crashes
- Error UI matches Appinium design
</success_criteria>

<output>
After completion, create `.planning/phases/05-quick-wins-tests/05-02-SUMMARY.md`
</output>
